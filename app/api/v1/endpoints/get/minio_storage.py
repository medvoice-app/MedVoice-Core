from minio import Minio
from minio.error import S3Error
from fastapi import HTTPException, APIRouter
import re, requests, json, os
from tempfile import NamedTemporaryFile

from .....core.minio_config import minio_config
from .....models.request_enum import *
from .....utils.storage_helpers import *
from .....utils.json_helpers import remove_json_metadata

router = APIRouter()


# Define the endpoints
@router.get("/get_audios_from_user/{id}")
async def get_audios_from_user_id(id: str):
    return await get_audios_from_user(id)


@router.get("/get_audio/{file_id}/{file_extension}")
async def get_audio_route(file_id: str, file_extension: AudioExtension):
    return await get_audio(file_id, file_extension)


@router.get("/buckets")
async def get_buckets_route():
    return await get_buckets()


@router.get("/get_json_transcripts_by_user/{user_id}")
async def get_transcripts_by_user(user_id: str):
    """Retrieve all patient data generated by the LLM for a specific user."""
    try:
        patients = []
        
        # Use MinIO
        storage = init_storage_client()
        client = storage["client"]
        bucket_name = storage["bucket_name"]
        
        # List all objects in the bucket
        objects = client.list_objects(bucket_name, recursive=True)
        
        for obj in objects:
            split_parts = obj.object_name.rsplit(".", 1)[0].rsplit("_", 2)
            if len(split_parts) < 3:
                continue
            
            user_id_in_obj = split_parts[-2]
            if user_id_in_obj == user_id and obj.object_name.endswith(".json"):
                # Download the JSON file to a temporary file
                with NamedTemporaryFile(delete=False, suffix='.json') as temp_file:
                    temp_path = temp_file.name
                
                try:
                    # Get the object data
                    client.fget_object(bucket_name, obj.object_name, temp_path)
                    
                    # Read the JSON data
                    with open(temp_path, 'r') as f:
                        json_data = json.load(f)
                    
                    # Process the data
                    patient_data = remove_json_metadata(json_data)
                    patients.append(patient_data)
                finally:
                    # Clean up the temporary file
                    if os.path.exists(temp_path):
                        os.unlink(temp_path)

        return {"patients": patients}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


async def get_audio(file_id: str, file_extension: AudioExtension):
    try:
        # Define a regex pattern to extract the fileID from object names
        pattern = r"date_(.*?)fileID_"
        
        # Use MinIO
        storage = init_storage_client()
        client = storage["client"]
        bucket_name = storage["bucket_name"]
        
        # List all objects in the bucket
        objects = client.list_objects(bucket_name, recursive=True)
        
        # Iterate over the objects to find the one that matches the file_id and extension
        for obj in objects:
            # Use regex to extract the fileID from the object name
            match = re.search(pattern, obj.object_name)
            if match:
                id_in_obj = match.group(1)
                # Check if the extracted fileID matches the 'file_id' and the file has the correct audio extension
                if id_in_obj == file_id and obj.object_name.endswith(f".{file_extension}"):
                    # Generate URL using internal container endpoint
                    protocol = 'http'  # Always use HTTP for internal container communication
                    
                    url = f"{protocol}://{minio_config['endpoint']}/{bucket_name}/{obj.object_name}"
                    return url

        # If no matching audio file is found, raise an HTTPException
        raise HTTPException(status_code=404, detail="Audio file not found")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


async def get_audios_from_user(id: str):
    try:
        # Create a list to store the URLs of the audio files
        audio_urls = []
        
        # Use MinIO
        storage = init_storage_client()
        client = storage["client"]
        bucket_name = storage["bucket_name"]
        
        # List all objects in the bucket
        objects = client.list_objects(bucket_name, recursive=True)
        
        # Iterate over the objects to find the ones that end with the id
        for obj in objects:
            # Split the object name by underscore and get the last part before the extension
            id_in_obj = obj.object_name.rsplit(".", 1)[0].rsplit("_", 1)[-1]
            
            # Check if the id in the object name matches the id
            if id_in_obj == id:
                # Generate URL using internal container endpoint
                protocol = 'http'  # Always use HTTP for internal container communication
                
                url = f"{protocol}://{minio_config['endpoint']}/{bucket_name}/{obj.object_name}"
                audio_urls.append(url)

        # Return the list of audio URLs
        return {"urls": sort_files_by_datetime(audio_urls)}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


async def get_buckets():
    """List MinIO buckets."""
    try:
        # Use MinIO
        storage = init_storage_client()
        client = storage["client"]
        
        # List buckets
        buckets = client.list_buckets()
        bucket_names = [bucket.name for bucket in buckets]
        
        return {"buckets": bucket_names}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
